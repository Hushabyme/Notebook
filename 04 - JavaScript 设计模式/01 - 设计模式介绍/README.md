# 第一章 介绍

设计模式最有价值的地方在于 —— 编写易于维护的代码，其中一个最重要的方面是能够找到代码中重复出现的主题并优化。

设计模式来源于土木工程师克里斯托弗 · 亚历山大的早期作品，它经常发表一些座屏，内容是总结他在解决涉及问题方面的问题的经验，他发现，重复使用这些模式可以使某些涉及构造取得我们所期望的最佳效果。

大约 30 多年前，软件工程师就开始吧亚历山大编写建筑设计原则纳入收个有关设计模式的文档中，成为初级开发人员改进变成技巧的指南。

那么，什么是模式呢？

> 模式就是一种可复用的解决方案，可以用于解决软件设计中遇到的常见问题。
>
> 另外一种模式是将解决问题的方法制作成模板，并且这些模板可以应用于不同的情况中。

设计模式有三大好处：

1. **模式是已经验证的解决方案。**
2. **模式很容易被复用。**
3. **模式富有表达力。**

这里我们要提到一个叫做“反模式”的术语，如果说一种设计模式代表一种最佳实践，那么反模式就是我们已经学习到的教训了。

## 反模式

关于什么是反模式？我举两个例子你就理解了：

- 向 setInterval 或 setTimeout 中添加字符串而不是函数，这样会导致调用 eval() 函数。
- 修改 Object 上的原型方法。
- 在全局上下文中大量定义全局变量。
- 滥用 document.write() 方法等。

以上的例子都可以被称作“反模式”，我们知道了什么是反模式以后，我们在设计自己的设计模式时就要避免出现这样的代码和形式。

## 设计模式类别

我们可以将设计模式分为不同的类别，在这一节中，我们简要的分为以下三种类型：

**1. 创建性设计模式** 

创建性设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。

属于这个类别的包括：Constructor（构造器）、Factory（工厂）、Abstract（抽象）、Prototype（原型）、Singleton（单例） 和 Builder（生成器）。

**2. 结构型设计模式**

结构性模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。这种模式有助于确保在系统某一部分变化时，系统的整个结构也不需要同时改变。同时对于不适合因某一特定目的而改变的系统部分，这种模式也能够帮助他重组。

属于这个类别的包括：Decorator（装饰者）、Facade（外观）、Flyweight（享元）、Adapter（适配器）和 Proxy（代理）。

**3. 行为设计模式**

行为模式专注于改善或简化系统中不同对象之间的通信。

行为模式包括：Iterator（迭代器）、Mediator（中介者）、Observer（观察者）和 Visitor（访问者）。

## 设计模式分类

我推荐大家将以此表格作为参考，但是要记住，这里还有很多未提及的其他模式。

先大致了解设计模式分分类以及它们是做什么的，这对后面的学习十分有好处。

| 创建性模式 | 基于创建对象的概念              |
| ----- | ---------------------- |
| 工厂方法  | 基于接口数据或事件生成几个派生类的一个实例  |
| 抽象工厂  | 创建若干类系列的一个实例，无需详述具体的类  |
| 生成器   | 从表示中分离对象创建；总是创建相同类型的对象 |
| 原型    | 用于复制或克隆完全初始化的实例        |
| 单例    | 一个类在全局访问点只有唯一一个实例      |

| 结构型模式 | 基于创建对象块的想法                   |
| ----- | ---------------------------- |
| 适配器   | 匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作 |
| 桥接    | 将对象接口从实现中分离，因此他们可以独立进行变化     |
| 组合    | 简单和符合对象的结构，使对象的综合不只是它各部分的总和  |
| 装饰    | 向对象动态添加备选的处理                 |
| 外观    | 隐藏整个子系统复杂性的唯一一个类             |
| 享元    | 一个用于实现包含在别处信息的高效共享的细粒度实例     |
| 代理    | 占位符对象代表真正的对象                 |

| 行为模式 | 基于对象在一起配合工作的方式               |
| ---- | ---------------------------- |
| 解释器  | 将语言元素包含在应用程序中的方法，以匹配预期语言的语法  |
| 模板方法 | 在方法中创建算法的 shell，然后将确切的步骤推到子类 |
| 职责链  | 在对象链之间传递请求的方法，以找到能够处理请求的对象   |
| 命令   | 将命令执行从其调用程序中分离的方法            |
| 迭代器  | 顺序访问一个集合中元素，无需了解该集合的内部工作原理   |
| 中介者  | 在类之间定义简化的通信，以防止一组显式引用彼此      |
| 备忘录  | 捕获对象的内部状态，以能够在以后恢复它          |
| 观察者  | 向多个类通知改变的方式，以确保类之间的一致性       |
| 状态   | 状态改变时，更改对象的行为                |
| 策略   | 在一个类中封装算法，将选择与实现分离           |
| 访问者  | 向类添加一个新的操作，无需改变类             |


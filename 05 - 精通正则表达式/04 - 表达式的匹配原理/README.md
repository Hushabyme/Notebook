# 第四章 表达式的匹配原理

我们为什么需要理解正则表达式的匹配原理呢？因为，基于此原理，构建正则表达式的**方式**决定了某个正则表达式**能否**匹配一个特定字符串，在**何处**匹配，以及匹配成功或失败的**速度**。

## 规则1：优先选择最左端的匹配结果

根据这条规则，起始位置最靠左的匹配结果总是优先于其它可能的撇配结果。这条规则并没有规定优先的匹配结果的长度，而只是规定，在所有可能的匹配结果中，优先选择开始位置最左端的。实际上，因为可能有多个匹配结果的其实位置都在最左端，也许我们应该吧这条规则中的“某个匹配结果”改为“该匹配结果”，不过或许有些别扭。

这条规则的由来是：匹配先从需要查找的字符串的起始位置尝试匹配。在这里，“尝试匹配”的意思是，在当前位置测试整个正则表达式（可能很复杂）能匹配的每样文本。如果在当前位置测试了所有可能之后不能找到匹配结果，就需要从字符串的第二个字符之前的位置开始重新尝试，并不断重复此过程。只有在所有的起始位置（直到最后一个字符）都不能匹配结果的情况下，才会报告“匹配失败”。

比如，如果要使用 `el` 来匹配 "Hello"，从字符串左边第一轮尝试会失败，因为 `el` 并不能匹配 `He` ，而第二轮则匹配成功。这时，引擎会停下来，报告匹配结果。

如果之前你不了解这条规则，那么你可能不能理解匹配的结果。例如使用 `cat` 匹配：

```
The dragging belly indicates that your cat is too fat.
```

结果并不是匹配到 `cat` 而是匹配到了 `indicates` ，因为该单词内部包含了连续的 "c a t"三个字符，注意，不要将它们读作 cat（猫），我们一开始就强调了，使用正则的思考方法来进行思维，因此它们只是相互独立的三个连续字符而已。

> 注意：这一条规则只关心 —— **“是否”**能够匹配，而不是**“在哪里”**匹配。

当然，在 JavaScript 中，你加上 `g` ，那么这两个单词就都可以被匹配到了。

### 引擎的构造

所有引擎都是由不同的零部件组合而成的。如果对零部件缺乏了解，那么也就不可能真正地理解引擎的工作原理。正则引擎中的这些零部件分为几类 —— 文字字符、量词、字符组、括号等等。所以，它们的组合方式以及它们之间的配合，使我们主要关注的东西。

首先，让我们来看看这些零部件：

1. 文字字符：

   对于非元字符的文字字符，尝试匹配时需要考虑的就是“这个字符与当前尝试的字符相同吗？”如果一个正则表达式只包含纯文本字符，例如 `cat` ，那么正则引擎会将其视为：一个 `c` ，接着一个 `a` ，再接着一个 `t` 。进行不区分大小写的情况可能要复杂一些，因为 `b` 既可以匹配 "b" 也可以匹配 "B"。 

2. 字符组、点号、Unicode 属性及其他

   通常情况下，这些元素的匹配都是比较简单的，无论字符组的长度是多少，它们都只能匹配一个字符。点号可以很方便地表示复杂的字符组，它几乎能匹配所有的字符，所以它的作用也很简单，其它的还包括例如 `\w` 、`\s` 、`\d` 等。

3. 捕获型括号

   用于捕获文本的括号（而不是分组的括号）不会影响匹配的过程。

4. 锚点（^、$ 等）

   锚点可以分为两大类：简单锚点和复杂锚点。简单锚点就是说，它们只是检查目标字符串中的特定位置的情况，例如 `^` 匹配开头；相反，复杂锚点（环视）能包含任意复杂的子表达式，所以它们可以任意复杂。 

## 规则2：标准量词是匹配优先的

至今为止，我们看到的特性都是非常易懂的，但仅仅靠它们还不够 —— 要完成复杂点的任务，就需要使用星号、加号、多选结构之类功能更强大的元字符。要彻底理解它们，就要学习更多的知识。

同学们所需要记住的是，标准匹配量词（+、*、? 以及 {min, max}）都是**“匹配优先”**的。如果用这些量词来约束某个表达式，例如 `a+` 中的 `a` ，在匹配成功之前，进行匹配的次数是存在上限和下限的。**而规则 2 则表明，这些尝试总是希望获取最长的匹配。**

简言之，标准匹配量词的结果“可能”并非所有可能中最长的，但它们总是尝试匹配尽可能多的字符，直到**匹配上限**为止。如果最终结果并非该表达式的所有可能中最长的，原因肯定是匹配字符过多导致匹配失败。

举个例子：如果用 `\b\w+s\b` 来匹配包含 "s" 的字符串，比如说 "regexes"，`\w+` 完全能够匹配整个单词，但如果用 `\w` 来匹配整个单词，`s` 就无法匹配了。因此为了完成匹配，就必须把最后的 `s\b` 留出来。

这可以是非常有用的（有时也非常讨厌）。它可以解释为什么 `[0-9]+` 可以匹配 "March·1998" 中所有的数字。"1" 匹配之后，已经满足了成功的下限，但正则表达式是匹配优先的，所以它不会停在此处，而会继续下去，继续匹配 "998"，直到字符串的末尾（因为这里并没有匹配后面的空档，所以会停下来）。

本章内容不多，很多内容都在书上，为什么这里没有继续做介绍了呢？原因是这本书有一些历史了。。。所以很多内容不适用于现在的环境中了。我就没有看了，但是还是比较精彩的。
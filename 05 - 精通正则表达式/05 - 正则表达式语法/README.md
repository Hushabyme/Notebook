# 第五章 正则表达式的模式匹配

JavaScript 的 RegExp 类表示正则表达式，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。

JavaScript 的正则表达式是 Perl5 的正则表达式的大型子集。

## 正则表达式的定义

JavaScript 中的正则表达式用 RegExp 对象表示，可以使用 `Regexp()` 构造函数来创建 RegExp 对象，不过 RegExp 对象更多的是通过一种特殊的直接量语法来创建。就是下列这样的形式：

```javascript
const pattern = /s$/;
```

使用构造函数也可以定义与之等价的正则表达式。就像对象构造函数与对象字面量的关系一样。

### 直接量字符

**表1：正则表达式的直接量字符**

| 字符       | 匹配                                       |
| -------- | ---------------------------------------- |
| 字母和数字字符  | 自身                                       |
| \o       | NUL 字符（\u0000）                           |
| \t       | 制表符（\u0009）                              |
| \n       | 换行符（\u000A）                              |
| \v       | 垂直制表符（\u000B）                            |
| \f       | 换页符（\u000C）                              |
| \r       | 回车符（\u000D）                              |
| \x*nn*   | 由十六进制数 *nn* 指定的拉丁字符，例如，\x0A 等价于 \n       |
| \u*xxxx* | 由十六进制数 *xxxx* 指定的 Unicode 字符，例如 \u0009 等价于 |
| \c*X*    | 控制字符 ^X，例如 \cJ 等价于换行符 \n                 |

此外，在正则表达式中，许多标点符号具有特殊含义，它们是：

^ $ . * + ? = ! : | \ / ( ) { }

接下来的几章里，我们将学习这些符号的含义。某些符号只有在正则表达式的某些上下文中才具有某种特殊含义，在其它上下文中则被当做直接量处理。

如果想在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀 `\` ，这是一条通行规则。如果不记得哪些标点符号需要用反斜杠转义，可以在每个标点符号前都加上反斜杠。

此外，许多字母和数字在有反斜杠做前缀时也有特殊含义，所以对于想按照直接量进行匹配的字母和数字，尽量不要用反斜杠来对其转义。除非是在正则表达式中按照直接量匹配反斜杠本身。

### 字符类

将直接量字符单独放在方括号内组成了字符类。一个字符类可以匹配它所包含的任意字符。因此，正则表达式 `/[abc]/` 就和字母 "a"、"b"、"c" 中的任意一个都匹配。另外，可以使用 `^` 来否定字符类，它匹配不包含在方括号内的字符。因此，正则表达式 `/[^abc]/` 就和字母 "a"、"b"、"c" 中的任意一个以外所有字符都匹配。

**表 2：正则表达式的字符类**

| 字符     | 匹配                                    |
| ------ | ------------------------------------- |
| [...]  | 方括号内的任意字符                             |
| [^...] | 不再方括号内的任意字符                           |
| .      | 除换行符和其它 Unicode 行终止符外的任意字符            |
| \w     | 任何 ASCII 字符组成的单词，等价于 [a-zA-Z0-9]      |
| \W     | 任何不是 ASCII 字符组成的单词，等价于 [ ^ a-zA-Z0-9] |
| \s     | 任何 Unicode 空白符                        |
| \S     | 任何非 Unicode 空白符                       |
| \d     | 任何 ASCII 数字，等价于 [0-9]                 |
| \D     | 除了 ASCII 数字之外的任何字符，等价于 [ ^0-9]        |
| [\b]   | 退格直接量（特例）                             |

> 注意：在方括号之内也可以写这些特殊转义字符。比如，由于 \s 匹配所有空白字符，\d 匹配所有数字，因此 `/[\s\d]/` 就匹配任意空白符或者数字。

### 重复

在刚刚学到的正则表达式的语法，可以把两位数描述成 `/\d\d/` ，四位数描述成 `/\d\d\d\d/` 。但到目前为止，还没有一种方法可以用来描述任意多位的数字，或者描述由三个字母和一个数字构成的字符串。

**表 3：正则表达式的重复字符语法**

| 字符    | 含义                                   |
| ----- | ------------------------------------ |
| {n,m} | 匹配前一项至少 n 次，但不超过 m 次                 |
| {n,}  | 匹配前一项 n 次或更多次                        |
| {n}   | 匹配前一项 n 次                            |
| ?     | 匹配前一项 0 次或 1 次，也就是说前一项是可选的，等价于 {0,1} |
| +     | 匹配前一项 1 次或多次，等价于 {1,}                |
| *     | 匹配前一项 0 次或多次，等价于 {0,}                |

这里还有一些例子：

```javascript
/\d{2,4}/;     // 匹配 2 ~ 4个数字
/\w{3}\d?/;    // 精确匹配三个单词和一个可选数字
/\s+java\s+/;  // 匹配前后带有一个或多个空格的字符串 "java"
/[^(]*]/;      // 匹配一个或多个非左括号的字符
```

> 注意：在使用 `*` 和 `?` 的时候要注意，由于它们可能匹配 0 个字符，因此它们允许什么都不匹配。比如 `/a*/` 实际上与 "bbbb" 匹配，因为该字符串含有 0 个 "a"。

#### 非贪婪重复

表 3 中列出的匹配重复字符是尽可能多地匹配，而且循序后续的正则表达式继续匹配。因此，我们称之为“贪婪的”匹配。因此，我们同样可以使用正则表达式进行非贪婪匹配。只需要待匹配的字符后跟一个问号即可："??"、"+?"、"*?" 或 "{1,5}?"。

比如我们使用 `/aaa/` 匹配 "aaa"，如果我们使用 `/a+?/` 则也可以匹配一个或多个连续字母 "a"，但是它会尽可能少的匹配。这种模式下，只能匹配第一个 "a"。 

### 选择、分组和引用

正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。

**表 4：选择、分组和引用**

| 字符      | 含义                                       |
| ------- | ---------------------------------------- |
| \|      | 选择，匹配的是该符号左边的表达式或右边的子表达式                 |
| (...)   | 组合，将几个项组合为一个单元，这个单元可以通过 `*` 、`+` 、`?` 和 `|` 等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供以后引用使用。 |
| (?:...) | 只组合，把项组合到一个单元，但不记忆与该组相匹配的字符              |
| \n      | 和第 n 个分组第一次匹配的字符相匹配，组是圆括号的子表达式（也有可能是嵌套的），组索引是从左到右的左括号数，`?:` 形式的分组不编码 |

接下来我们简单地介绍一下。

字符 `|` 用于分隔供选择的字符。例如，`/ab|cd|ef/` 可以匹配 "ab"，也可以匹配 "cd"，同时还可以匹配 "ef"。

> 注意：选择项的尝试匹配次序是从左到右，直到发现了匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配结果。因此，`/a|ab/` 匹配 "ab" 时，只能匹配 "a"，而不是 "ab"。

`()` 组合用法有很多，最简单就是 `/java(script)?/` 可以匹配 "java"，而后面的 "script" 可有，也可没有。

此外，圆括号的另一作用与在完整的模式中定义子模式。当一个正则表达式成功地和目标字符串匹配时，可以从目标中抽出和圆括号中的子模式相匹配的部分（我们后面再做介绍）。例如，`/[a-z]+\d+/` 用于检索一个或多个小写字母后面跟随一味或多为数字，假如我们只关心尾部的数字，那么，我们就可以用 `/[a-z]+(\d+/)` ，将模式的数字部分放在括号中，就可以到匹配中抽取数字了。

### 指定匹配位置

**表 5：正则表达式中的锚字符**

| 字符      | 含义                                       |
| ------- | ---------------------------------------- |
| ^       | 匹配字符串的开头，在多行检索中，匹配一行的开头                  |
| $       | 匹配字符串的结尾，在多行检索中，匹配一行的结尾                  |
| \b      | 匹配一个单词的边界，简言之，就是位于字符 `\w` 和 `\W` 之间的位置，或位于字符 `\w` 和字符串的开头或者结尾之间的位置（注意，[\b] 匹配的是退格符） |
| \B      | 匹配非单词边界的位置                               |
| (?=*p*) | 零宽正向先行断言，要求接下来的字符都与 *p* 匹配，但不能包括匹配 *p* 的那些字符 |
| (?!*p*) | 零宽负向先行断言，要求接下来的字符不与 *p* 匹配               |

### 修饰符

正则表达式语法还有最后一个知识点，即正则表达式的修饰符，用于说明高级匹配模式的规则。

表 6：正则表达式修饰符

| 字符   | 含义                                       |
| ---- | ---------------------------------------- |
| i    | 执行不区分大小写的匹配                              |
| g    | 执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止     |
| m    | 多行匹配模式，`^` 匹配一行的开头和字符串的开头，`$` 匹配行的结束和字符串的结束 |

## 用于模式匹配的 String 方法

到目前为止，尽管本章已经讨论过创建正则表达式的语法，但还没有尝试过如何在 JavaScript 代码中使用这些正则表达式。本节将讨论 String 对象的一些用以执行正则表达式模式匹配和检索替换操作的方法，后续几节还会继续讨论如何使用 JavaScript 正则表达式的模式匹配，不过将侧重于 RegExp 对象和它的方法及属性。

String 支持 4 种使用正则表达式的方法。

最简单的是 `search()`。它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回 -1，下面的调用返回值为 4：

```javascript
'JavaScript'.search(/script/i);
```

`replace()` 方法用以执行检索与替换操作。其中第一个参数是一个正则表达式，第二个参数是要进行替换的字符串。这个方法会对调用它的字符串进行检索，使用指定的模式来匹配。如果正则表达式中设置了修饰符 g，那么源字符串中所有与模式匹配的子串都将替换成第二个参数指定的字符串;如果不带修饰符 g，则只替换所匹配的第一个子串。

利用这个方法，将文本中所有的 "javascript"（不区分大小写）统一替换成 "JavaScript"。

```javascript
text.replace(/javascript/gi, 'JavaScript');
```

但 replace() 的功能远不止这些。回忆一下前文所提到的，正则表达式中使用圆括号括起来的子表达式是带有从左到右的索引编号的，而且正则表达式会记忆与每个子表达式匹配的文本。如果在替换字符串中出现了$加数字，那么 replace() 将用与指定的子表达式相匹配的文本来替换这两个字符。这是一个非常有用的特性。比如，可以用它将一个字符串中的英文引号替换为中文半角引号：

```javascript
// 一段引用文本起始于引号，结束于引号
// 中间的内容区域不能包含引号
var quote=/"([^"]*)"/g;
// 用中文半角引号替换英文引号，同时要保持引号之间的内容(存储在$1中)没有被修改
text.replace(quote, '$1');
```

replace() 方法还有一些其他重要特性，这些特使是关于 String 的。最值得注意的是，replace() 方法的第二个参数可以是函数，也就是说，该函数能够动态地计算替换字符串。

match() 方法是最常用的 String 正则表达式方法。它的唯一参数就是一个正则表达式(或通过 RegExp() 构造函数将其转换为正则表达式)，返回的是一个由匹配结果组成的数组。如果该正则表达式设置了修饰符 g，则该方法返回的数组包含字符串中的所有匹配结果。

如果这个正则表达式没有设置修饰符 g，match() 就不会进行全局检索，它只检索第一个匹配。但即使 match() 执行的不是全局检索，它也返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果 match() 返回一个数组。那么 a[0] 存放的是完整的匹配，a[1] 存放的则是与第一个用圆括号括起来的表达式相匹配的子串，以此类推。

例如，使用如下的代码来解析一个URL ：

```javascript
const url = /(\w+):\/\/([\w.]+)\/(\S*)/;
const text = "Visit my blog at http://www.example.com/~david";
const result = text.match(url);
result[0];  // 包含 "http://www.example.com/~david"
result[1];  // 包含 "http"
result[2];  // 包含 "www.example.com"
result[3];  // 包含 "~david"
```

split() 方法的参数也可以是一个正则表达式，这使得 split() 方法异常强大。例如，可以指定分隔符，允许两边可以留有任意多的空白符：

```javascript
"1, 2, 3, 4, 5".split(/\s*,\s*/);  // 返回 ["1", "2", "3", "4", "5"]
```

## RegExp 对象

RegExp() 构造函数带有两个字符串参数，其中第二个参数是可选的，RegExp() 用以创建新的RegExp对象。第一个参数包含正则表达式的主体部分，也就是正则表达式直接量中两条斜线之间的文本。需要注意的是，不论是字符串直接量还是正则表达式，都使用 "\" 字符作为转义字符的前缀，因此当给 RegExp() 传入一个字符串表述的正则表达式时，必须将 "\" 替换成 "\\\"。RegExp() 的第二个参数是可选的，如果提供第二个参数，它就指定正则表达式的修饰符。不过只能传入修饰符 g， i， m 或者它们的组合。比如：

```javascript
const zipcode = new RegExp('\\d{5}', 'g');
```

RegExp() 构造函数非常有用，特别是在需要动态创建正则表达式的时候，这种情况往往没办法通过写死在代码中的正则表达式直接量来实现。例如，如果待检索的字符串是由用户输入的，就必须使用 RegExp() 构造函数，在程序运行时创建正则表达式。

### RegExp 的属性

每个 RegExp 对象都包含 5 个属性。属性 source 是一个只读的字符串，包含正则表达式的文本。属性 global 是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符 g。属性 ignoretase 也是一个只读的布尔值，用以说明正则表达式是否带有修饰符 i。属性 multiline 是一个只读的布尔值，用以说明正则表达式是否带有修饰符 m。最后一个属性 lastIndex，它是一个可读/写的整数。如果匹配模式带有 g 修饰符，这个属性存储在整个字符串中下一次检索的开始位置，这个属性会被 exec() 和 test() 方法用到，下面会讲到。

### RegExp 的方法

RegExp 对象定义了两个用于执行模式匹配操作的方法。它们的行为和上文介绍过的
String方法很类似。RegExp 最主要的执行模式匹配的方法是 exec()，它与前面介绍过的 String 方法 match() 相似，只是 RegExp 方法的参数是一个字符串，而 String 方法的参数是一个 RegExp 对象。exec() 方法对一个指定的字符串执行一个正则表达式，简言之，就是在一个字符串中执行匹配检索。如果它没有找到任何匹配，它就返回 null，但如果它找到了一个匹配，它将返回一个数组，就像 match() 方法为非全局检索返回的数组一样。这个数组的第一个元素包含的是与正则表达式相匹配的字符串，余下的元素是与圆括号内的子表达式相匹配的子串。属性 index 包含了发生匹配的字符位置，属性 input 引用的是正在检索的字符串。

和 match() 方法不同，不管正则表达式是否具有全局修饰符 g,，exec() 都会返回一样的数组。

当 match() 的参数是一个全局正则表达式时，它返回由匹配结果组成的数组。相比之下，exec() 总是返回一个匹配结果，并提供关于本次匹配的完整信息。

另外一个 RegExp 方法是 test()，它比 exec() 更简单一些。它的参数是一个字符串，用 test() 对某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回 true。


# 第一章 正则表达式入门

想象以下这幅场景：你需要检索某台 Web 服务器上的重复单词（如 "this this"），在进行大规模的文本编辑的时候，这是一项十分常见的任务。

如果你从遇到过这样的场景，那么试想一下，你在使用 Word 编辑器进行某些词语的查找替换时，是通过使用 `查找/替换` 功能还是手动地一个一个去检索来的快速和方便呢？显然是使用 `查找/替换` 功能啦。

这就是正则表达式强大、便捷、高效的原因。

正则表达式其本身就可以看做是一种袖珍的编程语言，它拥有添加、查找、删除、分离、插入和替换各种类型的文本和数据的能力。

如果想要学会并学好正则表达式，那么我们就要学会用正则表达式来**思考**。

## 解决实际问题

掌握正则表达式，可能带来超乎你之前想象力的文本处理能力。假设你品势工作中使用不上它，但在最流行的 JavaScript 的库中，例如 jQuery、Vue 等，都存在使用正则表达式进行查找和替换文本的功能。

使用正则表达式节省下来的事件或许并不令人激动，但总比把时间浪费在文本编辑器中来的好。一旦掌握了正则表达式，你就会知道它简直就是工具中的无价之宝，你也很难想象没有正则表达式的日子是怎么度过的。

## 作为编程语言的正则表达式

选择这本书的读者，大概都是对“正则表达式”多少有点认识的。即使没有，也应该熟悉其中最基本的概念。

如果你接触过 Window，你一定不会对 `/*.txt/` 这样的形式感到陌生。其中 `* ` 表示匹配任意个字符，`.txt` 表示以 txt 结尾的文件。

不过，处理普通的文本就没有那么简单了。散文、诗句、程序代码、报表、HTML、表格、单词表...到你能想出的任何文本，我们都可以大明一种特殊的解决办法和工具来实现。不过近年来，一种 **“通用的模式语言”** 已经发展起来，而这种强大的语言和模式本身就被称为 **“正则表达式（regular expression）”**。

## 以语言做类比

完整的正则表达式由两种字符构成。一是特殊字符（special characters），就是我们上面看到的 `*` ，还有其它诸如 `^` 、`$` 等都被称为 **“元字符”（meta characters）**，而其它的字符就被称作 **“文字”（literal）**，或是 **普通文本字符**。

**为了便于理解，我们可以把正则表达式想象为普通的语言，普通字符对应普通语言中的单词，而元字符对应语法。根据语言的规则，按照语法把单词组合起来，就会得到能传达思想的文本。**

举一个例子，我们可以在 JavaScript 中使用 `/^(From|Subject):/` 寻找由 "From:" 或 "Subject:" 开头的行。

就像学习任意一门外语一样，第一眼看上去，正则表达式很不好理解，这也是为什么那些只对它有粗浅了解或根本不了解的人觉得正则表达式很神奇的原因。

相信在学习完这一本书的内容以后，我们都可以彻底明白并写出以下的正则表达式来：

```javascript
/[0-9]+(\.[0-9]+){3}/g
```

在后面的章节中，我们会了解到这个表达式的构造细节，然后根据自己的需求，在自己的应用程序或开发语言中应用这些技巧。

本书的目的不是提供具体问题的结局办法，而是教会你如何利用正则表达式来思考，解决遇到的各种问题。

## 正则表达式的思维框架

我们将会看到，完整的正则表达式是由小的构建模块单元（building block unit）组成。每个单独的构建模块都很简单，不过因为它们能够以无穷多种方式组合，将它们结合起来实现特殊目标就必须依靠经验了。

本章并没有艰深的内容，而是为本书其余章节的只是打下基础，在深入探索正则表达式之前，我们必须把相关事宜阐述清楚。

以下我将以 JavaScript 为例。

### 检索文本文件

文本检索是正则表达式最简单的应用之一。在 JavaScript 中，我们可以使用 `new new RegExp()` 或字面量表示法 `//` 来创建一个正则表达式的实例。

一般来说，我们通常使用 `//` 的形式来构建正则表达式，而使用 new 关键字构建的模式通常是在函数中需要动态创建时使用，例如：

```javascript
function reg(str) {
  return new RegExp(str);
}
```

示例：

```javascript
// 匹配所有包含 "A" 字母的部分
/A/g.test('Abc');  // true
/A/g.test('abc');  // false
```

### 元字符

#### 1. 行的起始和结束

或许在正则表达式中，最容易理解的要数 `^` 和 `$` 符号了。在检查一行文本时， `^` 表示一行的开始， `$` 表示结束。前面的示例中，我们看到检索包含 "A" 字母的部分，现在我们再来寻找一行中匹配 "cat" 的部分：

```javascript
/^cat/
```

以上的代码表示用于匹配文本以 "c a t" 开始的行，注意，这里我们将这三个字母分开来了。这是为什么？

我希望你们可以养成按照字符来理解正则表达式的习惯。例如，不要这样：

> `/^cat/` 匹配以 cat 开头的行。

而应该这样理解：

> `/^cat/` 匹配以 c 作为一行的第一个字符，紧跟一个 a，再紧跟一个 t 的文本。

这两种理解结果并无差异，但是按照字符来解读更易于明白新遇到的正则表达式的内部逻辑。

 `^` 和 `$` 这两个符号的特别之处就在于，它们匹配的是一个位置，而不是具体的文本。

### 字符组

#### 1. 匹配若干字符之一

如果我们需要搜索的单词是 "grey"，但是我们又不确定”灰色“是否又可以写作 "gray"。因此，我们就可以使用正则表达式结构体。它允许使用者列出在某处期望匹配的字符，通常被称作**”字符组“（character class）**。

而它所要用到的代码是：`[]` 。就是中括号。

```javascript
/gr[ea]y/
```

以上代码的意思是：先找到字符 g，后面紧跟着一个 r，然后是一个 a 或者一个 e，最后再紧跟一个 y。

需要注意的是，上面的 g 和 r 表示的是必须在一起，是**和（and）**的关系，而中括号中的 a 和 e 是**或（or）**的关系，既可以是 a，也可以是 e，但只能为其中之一。

例如：

```javascript
/gr[ea]y/.test('greay');  // false
```

了解了这些以后，我们再看另一个例子，我们还需要考虑到第一个字母为大写的情况，例如是 "Smith" 还是 "smith"。

下列这样的代码想必你一下子就能想出来了吧，真棒！

```javascript
/[Ss]mith/
```

**在一个字符组中我们可以列举任意多个字符。**例如匹配 h1 ~ h6 标签，就可以使用...我不说，你们都知道啦：

```javascript
/<h[123456]>/
```

但是，这还有一种简便的写法。

**在字符组内部，字符组元字符 "-"（连字符）表示一个范围。**

因此 `/<h[123456]>/` 与 `<h[1-6]>` 是一样的。

> **但是请注意，只有在字符组内部，连字符才是元字符！否则，它就只能匹配普通的连字符号。**

想必在之前接触 JavaScript 中正则表达式的同学应该都见过或多少知道的 0123456789 可以简写为 `[0-9]` 对吧，而 abcdefghijk... 同样也可以简写为 `[a-z]` 。

再举个例子：

```javascript
[0123456789abcdefABCDEF] 可以简写为 [0-9a-fA-F]
```

`[0-9a-fA-F]` 的顺序不重要，`[0-9A-Fa-f]` 也是一样的。

还记得前面我们讲到的  `^` 和 `$` 这两个符号吗？同样的道理，在 `[]` 内，这两个符号就不在拥有它以前的意义了。

例如在 `/[0-9A-Z_!.?^$]/` 中，真正的特殊字符也就只有那两个连字符号了。

#### 2. 排除型字符组

使用 `[^...]` 取代 `[...]` ，**这个字符组就会匹配任何未列出的字符**。

例如，我们使用 `[^1-6]` 就可以匹配除了 1 到 6 之外的任意字符。

> 注意，是任意字符！而不是任意数字！

虽然我们这里看到，`^` 和一开始提到的匹配行首是一个字符，但是意思却是迥然不同。

#### 3. 用点号匹配任意字符

元字符 `.` 用于匹配任意字符的字符组的简便写法。如果我们需要再表达式中使用一个“匹配任何字符”的占位符，用点号就很方便。

比如：

```javascript
/1.2.3/.test(112233);  // true
```

虽然有时候使用点号来匹配正则表达式可能结果不是我们所期望的，但是使用它是合理的。

### 多选结构

#### 1. 匹配任意子表达式

`|` （竖线）是一个非常简洁的元字符，他的意思是“或”（or）。在这样的组合中，子表达式称为“多选分支”。

例如使用 `/Alice|Bob/` 匹配 "Alice" 或 "Bob" 两个表达式。

我们回头来看上面所写的 `/gr[ea]y/` ，其实也可以写作 `/[gray|grey]/` ，又或者是 `/gr(a|e)y/` ，其实，这里你会发现，在正则表达式中，没有所谓的正确答案，它的组合是多种多样的。

注意上面  `/gr(a|e)y/` 这里的括号。如果省略了括号的话，那么就变成了匹配 "gra" 或 "ey" 了。

### 忽略大小写

我们在浏览器的地址栏输入 http 或 HTTP 都是可以的，但是我们使用正则表达式就不一样了，大写和小写是完全不一样的两个概念。

因此，我们就必须有一种模式可以忽略大小写的限制。想必你可能已经知道了，那就是 `i` ，也就是忽略大小写符号。

以下的结构都会返回 true。

```
/a/i.test('a');  // true
/a/i.test('A');  // true
```

### 单词分界符

使用正则表达式时经常会遇到一个问题，期望匹配的单词包含在另一个单词之中。

`\<` 和 `\>` 用于匹配单词分界的位置，可以把它想象成单词版本的  `^` 和 `$` 。但是，在 JavaScript 这门语言中并不支持，所以这里就不再做详细介绍了。

### 可选项元素

我们举一个单词来说，color，在某些地方，它被写作 colour，它们是同一个意思。就好比中文中的通假字类似。

我们可以使用 `?` 符号来匹配可选项。

例如：

```javascript
/colou?r/.test('color');  // true
/colou?r/.test('colour');  // true
```

以上代码的含义是：首先匹配 c 字母，再紧跟 o，接下来是 l，在接下来是 o，然后是 u?，最后是 r。

`u?` 是必然匹配成功的，它有时候会匹配一个 u，有时候则不匹配任何字符。关键在于，不论 u 是否出现，匹配都是成功的。但请注意，这并不代表着，任何包含 ? 的正则表达式都永远能匹配成功。

例如我们使用 `/colou?r/` 去匹配 "semicolon" 这个单词，你会发现，前面都能被匹配到，但最后的 r 却是不匹配的，因此，最终是不能匹配到这个单词的。

### 其它量词：重复出现

`+` 和 `*` 的作用与问号类似。元字符 `+` 表示之前紧邻的元素出现一次或多次，而 `*` 表示之前紧邻的元素出现零次或多次（即任意多次）。

因此，`+` 、 `*` 和 `?` 上个元字符，统称为 **“量词”（quantifiers）**。

这里我们又不得不提到 `{}` ，它被称为区间量词。

比如我们要匹配 0 到 5 个 a，那么我们可以这么写：

```javascript
/a{0,5}/
```

## 神奇的转义

我们还记得吗？`.` 是一个元字符。假如我们在匹配一个 url。其中的点应当怎么处理呢？

那么我们就要使用 `\` 来进行转义了。相信同学们都还记得 HTML 中的转义字符，没错，也是它。

我们可以使用它来匹配结尾为 .com 的网址：

```javascript
/(\.com)$/
```

## 改进现状

总的来说，正则表达式并不难。但是，如果你与使用过支持正则表达式程序或语言的人交流过，你就会发现，某些人确实“会用”正则表达式，但如果需要解决复杂的问题或换他们不熟悉的工具，就会出问题。

当然，我的意思并不是，本章的内容就可以弥补这道鸿沟，让同学们掌握所有的正则表达式。相反，本章只是做一个内容的铺垫，将正则表达式的一些基础术语和简单的例子告诉大家，让大家知道什么是正则表达式。

**而我们学习并学会正则表达式的唯一途径不单是大量的练习，更重要是学习用正则表达式的方式思考问题。**

而后面我们会讲到正则表达式的工作原理的时候，这是最重要也是最难理解和掌握的只是。研究这个问题有些枯燥，好比是，你只想学会开车，并不想学习汽车的运行原理。但是，我们学习正则表达式可不是学会开车这么简单，而是我们必须要学会如何造车，因此，我们才选择阅读这本书。

而再造汽车之前，我们就必须了解汽车的工作原理。

所以，请接着往下看吧。